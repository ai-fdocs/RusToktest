# План реализации пересборки модулей (с учетом текущей архитектуры)

Этот документ — практический план внедрения **WordPress/NodeBB‑стиля** для
модулей RusToK, где **install/uninstall = изменение манифеста → rebuild →
deploy**. План учитывает текущую архитектуру: модульный реестр формируется на
старте сервера, модули — Rust‑crates, а приложение уже содержит админ‑интерфейсы
(`apps/admin`).

## 0) Текущие реалии (от чего отталкиваемся)

- **Модули компилируются в бинарник**, а `ModuleRegistry` строится при старте
  сервера. Это означает, что установка “нового” модуля без сборки невозможна —
  требуется новый артефакт сборки.
- **Включение/выключение** модуля на tenant‑уровне уже решено через
  `tenant_modules` и `toggle_module` (runtime‑логика), но это не меняет набор
  модулей в бинарнике.
- Уже есть документация по **манифесту** и **admin rebuild blueprint** —
  это основа для формализации процесса пересборки и API‑интеграций.

## 1) Цели внедрения (что должно работать)

1. **Install/uninstall через админку**: админ изменяет список модулей,
   запускает сборку, видит статус и может откатиться.
2. **Источник правды** — `modules.toml` (или иной manifest), зафиксированный
   в репозитории/артефакте сборки.
3. **Сборка и деплой** происходят автоматически и воспроизводимо (монолитно или headless-профилем).
4. **Никакой runtime‑подгрузки нативного кода**, только пересборка.


## 1.1) Как при изменении модулей пересобираются admin и storefront

При install/uninstall меняется `modules.toml`, и rebuild должен считать это
изменением **трёх целевых артефактов**:

1. `apps/server` (backend + registry),
2. `apps/admin` (Leptos CSR),
3. `apps/storefront` (Leptos SSR).

Рекомендуемый workflow:
- Build-orchestrator вычисляет `manifest_hash`.
- По `manifest_hash` запускается единая build-задача с подзадачами
  `build_server`, `build_admin`, `build_storefront`.
- Каждая подзадача публикует свой артефакт (container/image bundle или static bundle).
- Deploy считается успешным только после успешного деплоя **всех обязательных**
  артефактов профиля (см. раздел 1.2).

Такой подход даёт согласованность: backend-контракты и UI, завязанный на
модульные фичи, обновляются синхронно в рамках одного release.

## 1.2) Два режима деплоя и пересборки

Поддерживаем два операционных режима:

### Режим A — "Монолитный релиз" (всё вместе)

- Один release-id, одна orchestrated pipeline-задача.
- Пересобираются и выкатываются `server + admin + storefront` в одном цикле.
- Откат выполняется на один общий `release_id`.

Когда использовать:
- единая инфраструктура,
- минимальная сложность эксплуатации,
- важна строгая консистентность версий между backend и UI.

### Режим B — "Headless / раздельные сервера"

- Backend (`apps/server`) деплоится отдельно.
- `apps/admin` и `apps/storefront` деплоятся как самостоятельные сервисы/артефакты.
- Install/uninstall модуля всё равно инициирует общий change-request, но
  оркестратор может запускать **раздельные пайплайны**: backend-first,
  затем `admin/storefront` (или параллельно).

Обязательные требования для режима B:
- version contract: совместимость `server` ↔ `admin/storefront` фиксируется
  явно (например, `compat.server = ">=0.1,<0.2"` в `module.toml`),
- preflight check перед деплоем UI против целевой backend-версии,
- отдельные rollback-политики для backend и UI, плюс аварийный флаг
  отключения модульных UI-фич до выравнивания версий.

## 2) Предлагаемая дорожная карта

### Этап A — Формализовать манифест и связать его с кодом

**Цель:** чтобы набор модулей *фактически* определялся манифестом.

Задачи:
1. **Выбрать файл манифеста** (например, `modules.toml`) и утвердить схему
   на уровне команды (ссылаться на спецификацию).
2. **Автоматизировать сборку реестра**:
   - добавить `xtask`/`build.rs`/скрипт, который генерирует код регистрации
     модулей на основе манифеста (например, `apps/server/src/modules/generated.rs`).
   - `build_registry()` импортирует сгенерированный список вместо
     “ручной” регистрации.
3. **Проверка на этапе CI**: если манифест изменился, а сгенерированный код
   не обновлён — билд должен падать.

Результат: **манифест становится единственным источником набора модулей.**

### Этап B — Минимальный Build‑Service (без админки)

**Цель:** дать команде способ запускать rebuild без UI, но с логами и статусом.

Задачи:
1. **Сервис‑обёртка** (отдельный сервис или job runner), который:
   - принимает `modules.toml` (или ссылку на git‑коммит),
   - запускает сборку,
   - публикует артефакт/образ,
   - сохраняет статус/логи.
2. **Минимальная модель данных** (таблица `builds` или внешнее хранилище):
   - `build_id`, `status`, `manifest_hash`, `started_at`, `finished_at`,
     `logs_url`, `release_id`, `profile` (`monolith` | `headless`).
3. **CLI/HTTP API** для запуска и статуса (достаточно пары эндпойнтов,
   как в blueprint) + параметр `profile` (`monolith`/`headless`).

Результат: **сборку можно запускать вручную/скриптом**, не дожидаясь UI.

### Этап C — Интеграция с админкой (Leptos-only UX)

**Цель:** UI‑кнопка “Install/Uninstall” с прогрессом сборки и деплоя.

Задачи:
1. **Admin API** (в `apps/server`) для:
   - создания rebuild‑задачи,
   - чтения статуса,
   - запуска deploy/rollback.
2. **UI в админке** (`apps/admin`):
   - управление списком модулей (manifest),
   - модальное окно статуса сборки,
   - история сборок/релизов.
3. **RBAC**: только админы/суперадмины могут запускать rebuild.

Результат: **полный “NodeBB‑подобный” опыт** — управляемые пересборки из UI.

### Этап D — Надёжность и контроль качества

**Цель:** сделать процесс безопасным для продакшна.

Задачи:
1. **Smoke‑checks** после деплоя:
   - health‑endpoint,
   - список модулей,
   - проверка миграций.
2. **Rollback** по `release_id` (политика хранения N релизов).
3. **Аудит‑лог** изменений манифеста (кто, когда, зачем).

Результат: **управляемый и безопасный цикл релизов**.

## 3) Детальные артефакты (что нужно создать)

- `modules.toml` (или аналог) — манифест.
- Отдельный репозиторий‑каталог модулей (marketplace), который содержит список
  доступных модулей и их метаданные в формате TOML (см. раздел 6).
- Генератор реестра (скрипт/xtask).
- Build‑service (job runner + хранение статусов).
- Админ‑API и UI.
- Документация для ops (pipeline + rollback).

## 4) Риски и способы смягчения

- **Долгая сборка** → показывать прогресс и статус, хранить логи.
- **Неудачная сборка** → не деплоить автоматически, требовать ручного деплоя.
- **Сломанный модуль** → проверка совместимости/версий в manifest lint.

## 5) Предлагаемая последовательность внедрения (минимальный MVP)

1. Манифест + генерация реестра (этап A).
2. Минимальный Build‑Service + CLI (этап B).
3. Админка + RBAC (этап C).
4. Rollback + мониторинг (этап D).

## 6) Marketplace модулей (репозиторий со списком)

Чтобы админка могла показывать **каталог модулей**, нужен отдельный репозиторий
со списком доступных модулей. Формат — TOML, чтобы быть совместимым с
`modules.toml` и легко парситься в Rust.

### 6.1 Формат каталога (пример `marketplace.toml`)

```toml
schema = 1
updated_at = "2026-02-01T12:00:00Z"

[modules.content]
slug = "content"
name = "Content"
description = "Base CMS module"
source = "crates-io"
crate = "rustok-content"
version = "0.1"
tags = ["cms", "core"]

[modules.forum]
slug = "forum"
name = "Forum"
description = "Forum module built on content"
source = "git"
crate = "rustok-forum"
git = "ssh://git/forum.git"
rev = "abc123"
tags = ["community"]
```

### 6.2 Поля каталога

| Поле | Тип | Обязательное | Описание |
| --- | --- | --- | --- |
| `schema` | int | да | Версия формата каталога. |
| `updated_at` | string | нет | Время последнего обновления. |
| `modules.*.slug` | string | да | Идентификатор модуля. |
| `modules.*.name` | string | да | Человеческое имя. |
| `modules.*.description` | string | нет | Описание. |
| `modules.*.source` | string | да | `crates-io` \| `git` \| `path`. |
| `modules.*.crate` | string | да | Имя crate. |
| `modules.*.version` | string | нет | Версия (для `crates-io`). |
| `modules.*.git` | string | нет | URL git‑репозитория. |
| `modules.*.rev` | string | нет | Commit SHA/тег. |
| `modules.*.tags` | array | нет | Категории/теги в UI. |

### 6.3 Как это используется

1. Админка скачивает `marketplace.toml` из репозитория каталога.
2. UI отображает список модулей (по тегам/поиску).
3. При выборе модуля админка **подставляет его spec** в `modules.toml`.
4. Дальше запускается rebuild по стандартному сценарию (манифест → build).

### 6.4 Пакеты для UI (только Leptos: admin + storefront)

> В рамках этого плана `apps/next-frontend` и любые Next.js-пакеты **исключены** из контура install/uninstall.

Для маркетплейса предполагается, что **каждый сторонний модуль** состоит минимум
из трёх частей:

1. **Серверный модуль** (Rust crate) — ядро бизнес-логики и API.
2. **Пакет для админки**:
   - `apps/admin`: Cargo‑crate/библиотека (Leptos UI).
3. **Пакет для фронтенда (витрины)**:
   - `apps/storefront`: Cargo‑crate/библиотека (Leptos UI).

Идея: если модуль **не подключён в манифест**, то его UI‑пакеты не попадают
в сборку; если подключён — сборка автоматически тянет нужные UI‑пакеты вместе
с серверной частью.

### 6.4.1 Эталонная реализация модуля (полная версия с таблицами)

Чтобы сторонние разработчики могли повторять процесс без догадок, нужен
**эталонный модуль** с максимально полным набором частей: server + admin UI +
storefront UI (Leptos). В качестве образца стоит взять **самый полный серверный модуль**
— то есть с таблицами, миграциями, CRUD, событиями и настройками.

Рекомендуемый состав и структура (монорепо‑формат, всё в одной папке модуля):

```
modules/rustok-catalog/
├─ crates/
│  ├─ catalog-server/          # Rust crate: таблицы, сущности, сервисы, GraphQL/REST
│  ├─ catalog-migrations/      # Rust crate: миграции SeaORM
│  └─ catalog-events/          # Rust crate: доменные события (если выделяются отдельно)
├─ admin/
│  └─ leptos/                  # Rust crate для apps/admin (Leptos UI)
├─ storefront/
│  └─ leptos/                  # Rust crate для apps/storefront (Leptos UI)
├─ module.toml                 # metadata/compatibility для marketplace
└─ README.md                   # краткая инструкция по локальной сборке/тестам
```

Минимальный функционал в эталонном серверном модуле:
- **Таблицы и миграции** (SeaORM), валидный MigrationSource.
- **Entities/DTO/Services** для CRUD.
- **События** (event publish) + outbox/transport.
- **Регистрация в ModuleRegistry** и зависимости.
- **Настройки модуля** (settings payload + schema).
- **API слой**: GraphQL-контракты для UI‑пакетов.
- **Сквозной пример фичи**: одна сущность, которая проходит через API → UI →
  сохранение → события (чтобы быстро понять end‑to‑end поток).
- **Готовые шаблоны** для UI‑пакетов (Leptos): формы, списки, empty‑state.
- **Быстрый старт**: короткий чек‑лист (создать/переименовать модуль, обновить
  manifest, запустить локальную сборку).

Дополнительно, чтобы модуль был максимально полезен внешним разработчикам:
- **Документация по структуре**: где менять схему БД, где API, где UI.
- **Минимальные тестовые сценарии** (ручные steps): без отдельной папки тестов,
  но с чёткими шагами проверки для локального окружения.
- **Локальный DX/скрипты**: набор команд для запуска server/admin/storefront в
  dev‑режиме, единая точка входа (Makefile/justfile) и пример `.env`.
- **Демо‑данные**: сиды для быстрой проверки UI и энд‑ту‑энд флоу.
- **Контракт версий**: правила совместимости server/admin/storefront и пример
  диапазонов (semver/compat section).
- **Схема `module.toml`**: явные поля для server/admin/storefront (Leptos) пакетов,
  чтобы сборка могла детерминированно подтянуть все части.
- **Публикация и релиз**: как выпускать модуль (теги/версии), и как сборка
  выбирает нужную версию из marketplace.
- **Миграции**: как модуль подключает MigrationSource и когда миграции
  исполняются в пайплайне (build/deploy).
- **RBAC для UI**: стандартные guard-правила для админки/витрины.
- **Event contract**: минимальный набор метаданных в событиях для совместимости
  со шиной и read-моделями.
- **Observability**: метрики/логи/трейсы и минимальный dashboard для модуля.
- **I18n/локализация**: правила для строк UI и переводов.
- **Security‑практики**: обработка прав, валидация входных данных, запреты на
  небезопасные операции в фоне/скриптах.

Задача эталонного модуля — показать полный end‑to‑end путь:
manifest → registry → UI‑пакеты → build → deploy.
Это критично для внешних разработчиков и для маркетплейса.

### 6.5 Надёжный механизм установки и сборки по команде бэкенда

Цель — сделать **детерминированный** и **безопасный** контур, где бэкенд
отдаёт команду “установить/удалить модуль”, а сборочная система выполняет её
через воспроизводимый пайплайн.

Минимальный набор компонентов:
1. **Admin API в бэкенде** (`apps/server`):
   - принимает запрос на install/uninstall,
   - сохраняет изменённый `modules.toml`,
   - создаёт запись `builds` со статусом `queued`,
   - публикует событие `BuildRequested`.
2. **Build‑orchestrator** (отдельный сервис или job‑runner):
   - подписан на `BuildRequested`,
   - забирает `modules.toml` (или `manifest_ref`),
   - выполняет **locked** сборку.
3. **Locked‑сборка** (без сетевой импровизации):
   - `cargo build --locked` для Rust‑части,
   - `cargo build --locked` для Leptos UI-частей (`apps/admin`, `apps/storefront`),
   - сборочные артефакты фиксируются хэшами.
4. **Deploy‑шаг** (atomic):
   - выкатывается новый образ/релиз,
   - health‑checks,
   - обновление статуса build в бэкенде.
5. **Rollback‑путь**:
   - хранить N релизов,
   - быстрый откат на последний стабильный `release_id`.

Дополнительно для надёжности:
- **Единый “source of truth”** — `modules.toml` + lockfiles Rust‑экосистемы (Cargo.lock).
- **Аудит**: кто запросил сборку, какие изменения в манифесте.
- **Гарантия идемпотентности**: повторный BuildRequested с тем же hash не запускает
  новую сборку, а возвращает уже готовый результат.

### 6.6 Предложения для дальнейшей реализации

1. **Module registry API для фронтенда/админки**:
   - эндпойнт, который возвращает список активных модулей и их версии;
   - UI скрывает/показывает функциональность на основании ответа.
2. **Изоляция build‑runner**:
   - сборка в отдельном контейнере;
   - ограничение сети (только registry);
   - подпись артефактов и проверка целостности.
3. **Проверки совместимости**:
   - связка версий server‑модуля ↔ UI‑пакетов;
   - preflight‑валидация перед запуском сборки.

---

Если нужно, следующий шаг — разложить эти этапы в задачи по репозиторию
(`apps/server`, `apps/admin`, `docs`, `CI`) и оценить трудозатраты.

This is an alpha version and requires clarification. Be careful, there may be errors in the text. So that no one thinks that this is an immutable rule.
